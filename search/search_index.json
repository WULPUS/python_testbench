{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Testbench Runner Documentation","text":"<p>This documentation provides an overview of the Testbench Runner, its architecture, and how to create and register new tools and tasks.</p> <ul> <li>Getting Started<ul> <li>Setup</li> <li>Basic Setup</li> </ul> </li> <li>Configuration</li> <li>Registry<ul> <li>Adding a New Tool</li> <li>Adding a New File</li> </ul> </li> <li>Structure</li> </ul>"},{"location":"basic_setup/","title":"Basic Setup","text":"<p>A minimal example of how to use the testbench:</p> <pre><code>from testbench import Testbench\n\n\nPATH = \"config/testbench.yml\"\n\ntb = None\ntry:\n    tb = Testbench(PATH)\n    tb.initialize_tasks()\n\n    tasks = tb.get_tasks()\n\n    print(\"Running testbench...\")\n    while not tb.is_done():\n        current = tb.iterate()\n\n    print(\"Done\")\n\nexcept Exception as e:\n    print(f\"Error running testbench: {e}\")\n</code></pre> <p>To see how to configure the testbench, see the configuration section.</p>"},{"location":"configuration/","title":"Configuration","text":""},{"location":"configuration/#testbenchyml","title":"<code>testbench.yml</code>","text":"<p>This configuration file contains the top-level testbench configuration. It contains the paths to the other configuration files, as well as the tasks to be executed in the testbench as well as their parameters.</p> <p>The <code>testbench.yml</code> file must contain the <code>files</code>, <code>tools</code>, and <code>schedule</code> fields, which are the paths to the <code>files.yml</code>, <code>tools.yml</code>, and <code>schedule.yml</code> files, respectively.</p> <p>Then, you can list all tasks to be executed under the <code>tasks</code> field.</p> <p>A task quite a long description. You can have the following fields:</p> <ul> <li><code>path</code>: Base path of the project which this path may describe, all other paths are relative to this path.</li> <li><code>tools</code>: Dictionary of tools to be used in the task, with some optional configurations for each tool.</li> <li><code>files</code>: Dictionary of files to be used in the task, with some optional configurations for each file.</li> </ul> <p>The configurations for a tool or file can vary from tool or file. They will be passed to the tool constructor or file class constructor, respectively.</p> <p>Here is an example of a <code>testbench.yml</code> file:</p> <pre><code>schedule: !inc config/schedule.yml\n\nregistry:\n  tools: !inc config/registry/tools.yml\n  files: !inc config/registry/files.yml\n\ntasks:\n  program_stm:   !inc config/tasks/program_stm.yml\n  test_frontend: !inc config/tasks/test_frontend.yml\n  deploy_keys:   !inc config/tasks/deploy_keys.yml\n</code></pre> <p>[!NOTE] The <code>!inc</code> directive is used to include other YAML files in the configuration. This allows you to split the configuration into multiple files for better organization and maintainability.</p> <p>You can also write the configuration directly in the <code>testbench.yml</code> file, but it is recommended to use the <code>!inc</code> directive to keep the configuration organized.</p>"},{"location":"configuration/#task-configuration","title":"Task Configuration","text":"<p>A task can look like this:</p> <pre><code>path: &lt;project_path&gt;/fw/stm32\n\ntools:\n  flasher:\n    name: openocd\n    interface: cmsis-dap\n    target: stm32l4\n\n  builder:\n    name: cmake\n\nfiles:\n  cmakelists:\n    path: .\n\n  c_header:\n    path: .\n    name: defines.h\n    configs:\n      DEVICE_NAME: TEST_DEVICE_NAME\n</code></pre> <p>Here, we define an example task that builds and flashes a firmware project for an STM32 microcontroller.</p> <p>The <code>path</code> field specifies the base path of the project, which is used to resolve relative paths for files and tools.</p> <p>We use two tools in this task: a flasher and a builder. The <code>flasher</code> tool is used to flash the firmware to the microcontroller, while the <code>builder</code> tool is used to build the firmware project. Each tool has a <code>name</code> field that specifies the tool type to be used, and additional parameters that are passed to the tool when it is executed.</p> <p>We also define two files to be used in the task: a <code>CMakeLists.txt</code> file and a C header file. Each file has a <code>path</code> field that specifies the path to the file relative to the base path of the task. Optionally, you can also specify a <code>name</code> field to specify the specific name of the file, otherwise a suitable file will be chosen based on the file type.</p> <p>The <code>cmakelists</code> file is used to configure the build system, while the <code>c_header</code> file is used to define some constants that will be used in the firmware code. The <code>configs</code> field allows you to specify some configurations for the file, which will be passed to the file class when it is instantiated.</p>"},{"location":"configuration/#filesyml","title":"<code>files.yml</code>","text":"<p>This configuration file contains all file types available to the testbench. A file type is a means for the testbench (or its tools) to read, manipulate and use its contents by describing it using a Python class.</p> <p>The <code>files.yml</code> file must contain the <code>path</code> field; This is the path to the directory where the file classes are located (default: <code>registry/files</code>).</p> <p>You can then list all file types directly next to the <code>path</code> field, as a key-value pair with the file type as the key and the class name as the value. The file type is used to identify the file in the testbench, and the class name is used to instantiate the file class.</p> <p>Here is an example of a <code>files.yml</code> file:</p> <pre><code>path: registry/files\n\nmakefile: Makefile\ncmakelists: CMakeLists\n</code></pre>"},{"location":"configuration/#toolsyml","title":"<code>tools.yml</code>","text":"<p>This configuration file contains all tools available to the testbench. A tool is a means for the testbench to run a command on the system, such as a compiler or a flasher by describing it using a Python class.</p> <p>The <code>tools.yml</code> file must contain the <code>path</code> field; This is the path to the directory where the tool classes are located (default: <code>registry/tools</code>).</p> <p>A tool can be part of a tool type, which means that it can be used in a specific context, such as a compiler or a flasher. You can list all tool types directly next to the <code>path</code> field, with the id to be used in other configurations as the key and a list of tools as key-value pairs with the tool type as the key and the class name as the value.</p> <p>Here is an example of a <code>tools.yml</code> file:</p> <pre><code>path: registry/tools\n\nbuilder:\n  makefile: BuilderMakefile\n  cmake: BuilderCMake\n\nflasher:\n  makefile: FlasherMakefile\n  openocd: FlasherOpenOCD\n</code></pre>"},{"location":"configuration/#scheduleyml","title":"<code>schedule.yml</code>","text":"<p>This configuration file contains the schedule for the testbench. A schedule is a list of tasks (described in <code>testbench.yml</code>) to be executed in a specific order, with each project having a set of steps to be executed.</p> <p>Each task has to contain the <code>order</code> field, which is a number that determines the order in which the task will be executed. The lower the number, the earlier the task will be executed. Multiple tasks can have the same order, in which case they will be executed concurrently.</p> <p>Each task then contains the <code>steps</code> and <code>cleanup</code> fields, which are lists of steps to be executed. The <code>steps</code> field contains the steps to be executed before the task is considered complete, while the <code>cleanup</code> field contains the steps to be executed after the task is complete, regardless of whether it was successful or not.</p> <p>A task step is a key-value pair, where the key is the step function (e.g. <code>build</code>, <code>erase</code>, <code>flash</code>, <code>clean</code>) and the value is a string of the form <code>tool_type;tool_id</code>. The tool type is the type of tool to be used (e.g. <code>builder</code>, <code>flasher</code>), and the tool id is the id of the tool to be used (e.g. <code>makefile</code>, <code>ses</code>).</p> <p>Here is an example of a <code>schedule.yml</code> file:</p> <pre><code>program_stm:\n  order: 1\n  steps:\n    build: builder;cmake\n    erase: flasher;openocd\n    flash: flasher;openocd\n  cleanup:\n    clean: builder;cmake\n\ntest_frontend:\n  order: 2\n  steps:\n    test_excitation: tester;ad2\n    test_reception: tester;ad2\n\ndeploy_keys:\n  order: 3\n  steps:\n    deploy: backend;javascript\n</code></pre>"},{"location":"configuration/#env","title":"<code>.env</code>","text":"<p>As you can see in the example above, some paths are defined as <code>&lt;project_path&gt;</code>. These are environment variables that you can define in a <code>.env</code> file in the root of the project. The testbench will automatically load these variables and replace them in the configuration files.</p> <p>A tool or file can also reference environment variables in their configurations, which will be replaced by the testbench when the task is executed.</p> <p>Here is an example of a <code>.env</code> file:</p> <pre><code>PROJECT_PATH=C:/dev/company/cool_device\n</code></pre> <p>To find out more about how to use the tools and files, see the tools and files documentation.</p>"},{"location":"new_file/","title":"Adding a New File","text":"<p>Here, we register a new example file to the testbench. We want this file to be a simple text file that contains a greeting, to be used in the <code>greet_user</code> task we created earlier.</p>"},{"location":"new_file/#creating-a-concrete-file-implementation","title":"Creating a Concrete File Implementation","text":"<p>For this, we create a new file type <code>greeting</code> in <code>registry/files/file_greeting.py</code>:</p> <pre><code>from pathlib import Path\nfrom typing import Optional\n\nfrom testbench import File\n\n\nclass Greeting(File):\n    def __init__(\n        self, path: Path, configs: dict, output_dir: Path, name: Optional[str] = None\n    ):\n        super().__init__(path, \"txt\", configs, output_dir, name)\n</code></pre> <p>As you can see, this class inherits from the <code>File</code> base class, which provides some basic functionality for the file, including the <code>parse</code> method, which is used to read the file and extract the relevant information. In this case, we do not need to implement the <code>parse</code> method, since it already is a basic implementation that replaces placeholders in the file with the actual values from the <code>configs</code> dictionary.</p>"},{"location":"new_file/#testing-the-tool","title":"Testing the Tool","text":"<p>We then register the new file type in the <code>config/registry/files.yml</code> file by adding the following entry:</p> <pre><code>path: registry/files\n\ngreeting: Greeting\n</code></pre> <p>We then add this file to the <code>greet_user</code> task in the <code>config/tasks/greet_user.yml</code> file:</p> <pre><code>path: test # Now, we use the test directory as the project path\n\ntools:\n  hello:\n    name: file\n    user: Cedric # We pass the user name as a parameter to the tool\n\nfiles:\n  greeting:\n    path: .\n    name: greeting.txt\n    configs:\n      USER_NAME: Cedric # We pass the user name as a configuration to the file\n</code></pre> <p>We create a new file <code>test/greeting.txt</code> with the following content:</p> <pre><code>Hello, USER_NAME!\n</code></pre> <p>Since we use the <code>greeting</code> file type, the testbench will automatically read the <code>greeting.txt</code> file and replace the <code>USER_NAME</code> placeholder with the actual user name <code>Cedric</code>. We thus do not need to add any additional steps to the <code>schedule.yml</code> file, since the <code>greeting</code> file type will handle the replacement automatically.</p> <p>This will then produce the same output as before, but now we also have a <code>files</code> directory in the task output directory that contains the <code>greeting.txt</code> file with the following content:</p> <pre><code>Hello, Cedric!\n</code></pre> <p>This means that the <code>USER_NAME</code> placeholder in the <code>greeting.txt</code> file was replaced with the actual user name <code>Cedric</code>.</p> <p>As well as <code>greeting.bak</code>, which is a backup of the original file before the replacement was made.</p> <p>[!NOTE] In the future, the functionality of directly writing to a file will be moved to the <code>File</code> base class, so that all file types can use it. This will make it easier to create new file types that need to write to a file. Also, we should be able to create new files and not relay on existing files, so that we can create files from scratch.</p> <p>To find out more about how to create and register new tools and tasks, see the new tool documentation.</p> <p>To find out more about the structure of the testbench, see the structure documentation.</p>"},{"location":"new_tool/","title":"Registering a New Task/Tool","text":"<p>Here, we register a new example tool to the testbench. We want this tool to write \"Hello, &lt;name&gt;!\" to a file called <code>greeting.txt</code> in the current tasks output directory.</p>"},{"location":"new_tool/#creating-a-new-tool-type","title":"Creating a New Tool Type","text":"<p>For this, we register a new tool type <code>hello</code> in the <code>tools</code> directory by creating its own directory:</p> <pre><code>mkdir registry/tools/hello\n</code></pre>"},{"location":"new_tool/#creating-a-tool-type-base-class","title":"Creating a Tool Type Base Class","text":"<p>Then, we create a new tool type base class in the <code>registry/tools/hello/hello.py</code> file:</p> <pre><code>from testbench import Tool\n\n\nclass Hello(Tool):\n    def __init__(self, name: str, task: dict, params: dict, env: dict):\n        super().__init__(\"hello\", name, task, params, env) # Initialize the base class with the tool type \"hello\"\n\n    def greet(self) -&gt; None:\n        raise NotImplementedError # We will implement this method in a subclass\n</code></pre> <p>As you can see, this class inherits from the <code>Tool</code> base class, which provides some basic functionality for the tool. The <code>greet</code> method is a placeholder for the actual implementation of the tool in a subclass.</p> <p>[!NOTE] The <code>Tool</code> base class provides some basic functionality for the tool, such as the <code>ensure</code> method to ensure that a parameter or file is present and the <code>run_command</code> method to run a command.</p>"},{"location":"new_tool/#creating-a-concrete-tool-implementation","title":"Creating a Concrete Tool Implementation","text":"<p>We can now create the concrete implementation of the hello tool type, for example a <code>HelloFile</code> tool that writes the greeting to a file. We create a new file <code>registry/tools/hello/hello_file.py</code>:</p> <pre><code>from registry.tools.hello.hello import Hello\n\n\nclass HelloFile(Hello):\n    def __init__(self, task: dict, params: dict, env: dict):\n        super().__init__(\"file\", task, params, env)\n\n        self.user = self.ensure(\"params\", \"user\") # We cannot use `name` here, since it is reserved for the tool name\n\n    def greet(self) -&gt; None:\n        with open(self.output_dir / \"greeting.txt\", \"w\") as f:\n            f.write(f\"Hello, {self.user}!\\n\")\n</code></pre>"},{"location":"new_tool/#testing-the-tool","title":"Testing the Tool","text":"<p>First, we need to register the new tool and its type in the <code>config/registry/tools.yml</code> file. We add the following entry to the <code>config/registry/tools.yml</code> file:</p> <pre><code>path: registry/tools\n\nhello:\n  file: HelloFile\n</code></pre> <p>[!WARNING] Here, the naming is important: The key <code>hello</code> is the tool type, and the value <code>file</code> is the name of the concrete implementation of the <code>HelloFile</code> class. The testbench will use this to search for the tool class when it is instantiated. In this case, the testbench will look for the <code>HelloFile</code> class in the <code>registry/tools/hello/hello_file.py</code> file. If we were to write: <pre><code>path: registry/tools\n\nhello:\n  console: HelloPrint\n</code></pre> Then, the testbench would look for the <code>HelloPrint</code> class in the <code>registry/tools/hello/hello_console.py</code> file.</p> <p>We then use this in the <code>config/testbench.yml</code> and <code>config/tasks/greet_user.yml</code> files to create a task that uses this tool:</p> <pre><code>tasks:\n  greet_user: !inc config/tasks/greet_user.yml\n</code></pre> <pre><code>path: . # For now, we use the current directory as the project path, since we don't have a specific project path\n\ntools:\n  hello:\n    name: file\n    user: Cedric # We pass the user name as a parameter to the tool\n</code></pre> <p>As you can see, we use the tool type <code>hello</code> with the tool name <code>file</code>, which is the concrete implementation of the <code>HelloFile</code> class. We also pass a parameter <code>user</code> with the value <code>Cedric</code>, which will be used in the tool to greet the user.</p> <p>We add the task to the <code>schedule.yml</code> file:</p> <pre><code>greet_user:\n  order: 1\n  steps:\n    greet: hello;file\n</code></pre> <p>As you can see, we define the step <code>greet</code> with the tool type <code>hello</code> and the tool name <code>file</code>, which will execute the <code>greet</code> method of the <code>HelloFile</code> class.</p>"},{"location":"new_tool/#running-the-new-tool","title":"Running the New Tool","text":"<p>Running the testbench with the added tool will produce the following output in the terminal:</p> <pre><code>[12:00:00] INFO     Testbench:                                               testbench.py:27\n                    'C:\\dev\\testbench\\config\\testbench.yml'                   \n           INFO     Output directory: 'output\\20250101-120000'               testbench.py:37\n           INFO     Tools: 'registry\\tools'                                      tools.py:16\n           INFO     Initialized 3 tool types with 9 tools                        tools.py:24\n           INFO     Files registry: registry\\files                               files.py:16\n           INFO     Initialized 1 tasks with 1 tools                             tasks.py:20\n           INFO     Initialized testbench                                    testbench.py:98\n           INFO     Initialized 1 tasks with 0 files and 1 tools            testbench.py:189\n           INFO     Running testbench...                                          main.py:36\n           INFO     Running task: greet_user                                 schedule.py:163\n           INFO     Running step: greet_user/hello/greet                     schedule.py:166\n           INFO     Done (0.00s): greet_user/hello/greet                     schedule.py:171\n           INFO     Done                                                          main.py:40\n</code></pre> <p>You can see that the testbench initialized the tools and files, and then executed the <code>greet_user</code> task. The output directory is <code>output/20250101-120000</code>, which contains the output of the tool. You can find the greeting in the <code>output/20250101-120000/greet_user/hello_file/greeting.txt</code> file:</p> <pre><code>Hello, Cedric!\n</code></pre> <p>You can also see that the output directory is created with a timestamp, so you can run the testbench multiple times without overwriting the output.</p> <p>[!NOTE] All of this seems very complex and it is, but with a growing number of tools and files, it is necessary to keep the testbench organized and maintainable. The testbench is designed to be extensible, so you can easily add new tools and files without having to change the existing code.</p> <p>To find out more about how to create and register new files, see the new file documentation.</p> <p>To find out more about the structure of the testbench, see the structure documentation.</p>"},{"location":"setup/","title":"Setup","text":"<p>This project requires the uv Python package to run. You can install it using pip:</p> <pre><code>pip install uv\n</code></pre> <p>This library can be included in a Python project as a submodule. If you add the submodule to the base directory of your project, you need to add the following line to the <code>pyproject.toml</code> file:</p> <pre><code>[tool.uv.workspace]\nmembers = [\"python_testbench\"]\n\n[tool.uv.sources]\npython_testbench = { workspace = true }\ntestbench = { workspace = true }\n</code></pre> <p>And then add the testbench via the command:</p> <pre><code>uv add python_testbench\n</code></pre> <p>Now, you can move to a basic setup to get started with the testbench.</p>"},{"location":"structure/","title":"Structure","text":""},{"location":"structure/#overall-architecture","title":"Overall Architecture","text":"<pre><code>graph TB\n    subgraph \"Configuration Files\"\n        TB_CONFIG[testbench.yml]\n        SCHEDULE_CONFIG[schedule.yml] --&gt; TB_CONFIG\n        TOOLS_CONFIG[tools.yml] --&gt; TB_CONFIG\n        FILES_CONFIG[files.yml] --&gt; TB_CONFIG\n        ENV_FILE[.env] --&gt; TB_CONFIG\n    end\n\n    subgraph \"Main Application\"\n        MAIN[main.py]\n        TESTBENCH[Testbench Class]\n    end\n\n    subgraph \"Core Components\"\n        SCHEDULE[TestbenchSchedule]\n        TASKS[TestbenchTasks]\n        TOOLS[TestbenchTools]\n        FILES[TestbenchFiles]\n    end\n\n    subgraph \"Registry System\"\n        TOOL_REGISTRY[Tool Registry]\n        FILE_REGISTRY[File Registry]\n        TOOL_BASE[Tool Base Classes]\n        FILE_BASE[File Base Classes]\n    end\n\n    subgraph \"Execution\"\n        TASK_INSTANCES[Task Instances]\n        TOOL_INSTANCES[Tool Instances]\n        FILE_INSTANCES[File Instances]\n    end\n\n    MAIN --&gt; TESTBENCH\n    TB_CONFIG --&gt; TESTBENCH\n\n    TESTBENCH --&gt; SCHEDULE\n    TESTBENCH --&gt; TASKS\n    TESTBENCH --&gt; TOOLS\n    TESTBENCH --&gt; FILES\n\n    TB_CONFIG --&gt; SCHEDULE\n    TB_CONFIG --&gt; TOOLS\n    TB_CONFIG --&gt; FILES\n\n    TOOLS --&gt; TOOL_REGISTRY\n    FILES --&gt; FILE_REGISTRY\n\n    TOOL_REGISTRY --&gt; TOOL_BASE\n    FILE_REGISTRY --&gt; FILE_BASE\n\n    TASKS --&gt; TASK_INSTANCES\n    TASK_INSTANCES --&gt; TOOL_INSTANCES\n    TASK_INSTANCES --&gt; FILE_INSTANCES\n\n    SCHEDULE --&gt; TASK_INSTANCES</code></pre>"},{"location":"structure/#testbench-initialization-flow","title":"Testbench Initialization Flow","text":"<pre><code>sequenceDiagram\n    participant Main as main.py\n    participant TB as Testbench\n    participant Tools as TestbenchTools\n    participant Files as TestbenchFiles\n    participant Tasks as TestbenchTasks\n    participant Schedule as TestbenchSchedule\n\n    Main-&gt;&gt;TB: new Testbench(config_path)\n    TB-&gt;&gt;TB: Load testbench.yml config\n    TB-&gt;&gt;TB: Create output directory\n    TB-&gt;&gt;TB: Handle environment variables\n\n    TB-&gt;&gt;Tools: new TestbenchTools(tools_config)\n    Tools-&gt;&gt;Tools: Load tools registry\n    Tools-&gt;&gt;Tools: Register tool types &amp; classes\n    Tools--&gt;&gt;TB: Return available tools\n\n    TB-&gt;&gt;Files: new TestbenchFiles(files_config)\n    Files-&gt;&gt;Files: Load files registry\n    Files-&gt;&gt;Files: Register file types &amp; classes\n    Files--&gt;&gt;TB: Return available files\n\n    TB-&gt;&gt;Tasks: new TestbenchTasks(tasks_config, tools, files)\n    Tasks-&gt;&gt;Tasks: Parse task configurations\n    Tasks-&gt;&gt;Tasks: Validate tool/file references\n    Tasks--&gt;&gt;TB: Return configured tasks\n\n    TB-&gt;&gt;Schedule: new TestbenchSchedule(schedule_config, tools, tasks)\n    Schedule-&gt;&gt;Schedule: Parse execution schedule\n    Schedule-&gt;&gt;Schedule: Sort tasks by order\n    Schedule--&gt;&gt;TB: Return execution schedule\n\n    Main-&gt;&gt;TB: initialize_tasks()\n    TB-&gt;&gt;TB: Instantiate file objects\n    TB-&gt;&gt;TB: Instantiate tool objects\n    TB-&gt;&gt;TB: Link tools to scheduled steps</code></pre>"},{"location":"structure/#task-execution-flow","title":"Task Execution Flow","text":"<pre><code>sequenceDiagram\n    participant Main as main.py\n    participant TB as Testbench\n    participant Schedule as TestbenchSchedule\n    participant Task as Task Instance\n    participant Tool as Tool Instance\n    participant File as File Instance\n\n    Main-&gt;&gt;TB: iterate()\n    TB-&gt;&gt;Schedule: iterate()\n\n    Schedule-&gt;&gt;Schedule: Get next task group by order\n    Schedule-&gt;&gt;Schedule: Execute tasks in parallel (same order)\n\n    loop For each task in current order\n        Schedule-&gt;&gt;Task: Execute task steps\n\n        loop For each step in task\n            Task-&gt;&gt;File: parse() - Process input files\n            File-&gt;&gt;File: Replace placeholders with configs\n            File--&gt;&gt;Task: Return processed file\n\n            Task-&gt;&gt;Tool: execute_step() - Run tool function\n            Tool-&gt;&gt;Tool: Prepare environment\n            Tool-&gt;&gt;Tool: Execute command/operation\n            Tool-&gt;&gt;Tool: Log output to task directory\n            Tool--&gt;&gt;Task: Return execution result\n        end\n\n        Task-&gt;&gt;Task: Execute cleanup steps\n        Task--&gt;&gt;Schedule: Task completed\n    end\n\n    Schedule--&gt;&gt;TB: Current iteration done\n    TB--&gt;&gt;Main: Continue or finish</code></pre>"},{"location":"structure/#tool-and-file-architecture","title":"Tool and File Architecture","text":"<pre><code>classDiagram\n    class Tool {\n        +type: str\n        +type_name: str\n        +task: dict\n        +params: dict\n        +env: dict\n        +output_dir: Path\n        +log: Logger\n\n        +__init__(type: str, name: str, task: dict, params: dict, env: dict)\n        +run_command(source: str, type: str)\n        +ensure(loc: str, variable: str) Any\n        +run(command_name: str)\n    }\n\n    class Builder {\n        +build()\n        +clean()\n    }\n\n    class Flasher {\n        +erase()\n        +flash()\n    }\n\n    class BuilderMakefile {\n        +target: str\n        +build()\n        +clean()\n    }\n\n    class BuilderSES {\n        +project_file: Path\n        +build()\n        +clean()\n    }\n\n    class FlasherMSPFlash {\n        +hex_path: Path\n        +erase()\n        +flash()\n    }\n\n    class File {\n        +configs: dict\n        +replacements: dict\n        +file: Path\n        +output_dir: Path\n\n        +__init__(path: Path, extension: str, configs: dict, output_dir: Path, name: Optional[str] = None)\n        +parse()\n    }\n\n    class Makefile {\n        +target: str\n        +parse()\n    }\n\n    class CHeader {\n        +defines: dict\n        +parse()\n        +update_defines()\n    }\n\n    Tool &lt;|-- Builder\n    Tool &lt;|-- Flasher\n    Builder &lt;|-- BuilderMakefile\n    Builder &lt;|-- BuilderSES\n    Flasher &lt;|-- FlasherMSPFlash\n\n    File &lt;|-- Makefile\n    File &lt;|-- CHeader</code></pre>"}]}